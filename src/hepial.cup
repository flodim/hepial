/*
Project: hepial compiler
Description: This is a compiler for hepial a custom language
			This si the cup file that contain the grammar rules.
Author: Florian Hassler & Dimitri Lizzi
Date: 14.01.2018
 */
import java_cup.runtime.*;
import java.io.*;
import symbole_table.*;
import abstract_tree.*;
import java.util.*;

parser code {:
private Stack<AbstractTree> treeStack;

private void enterBlock(){ SymbTable.getInstance().enterBlock(); }
private void exitBlock(){ SymbTable.getInstance().exitBlock();}
private void addSymbol(Entry entry, Symb symbol){  SymbTable.getInstance().add(entry,symbol); }

 :};

init with {:

treeStack=new Stack<AbstractTree>();

:};

terminal PRG, STARTPRG, ENDPRG, STARTFUNC, ENDFUNC, CONSTANT, COMMENT;
terminal SEMICOLON, OPENPARENT, CLOSEPARENT, EQUAL, COMMA, DOUBLEPOINTS;
terminal OPENBRACK, CLOSEBRACK, PLUS, MINUS, TILDA, TIMES, NOT, AND, OR, DIVIDE;
terminal EQUALS, DIFF, INF, SUP, INFEQUAL, SUPEQUAL, TRUESYM, FALSESYM;
terminal WHILESYM, DOSYM, ENDWHILE, IFSYM, THEN, ELSESYM, ENDIF;
terminal FORSYM, FROM, TO, ENDFOR, READ, WRITE, RETURNSYM;

terminal Integer INTEGERCONST;
terminal String STRINGCONST;
terminal String IDENT;
terminal String TINTEGER;
terminal String TBOOLEAN;

non terminal axiome, programme, entete, decla, declavar, declaconst ,decla_star, declafonct;
non terminal dim, expr, param, body, instr, affect;
non terminal write_instr, read_instr, cond, while_instr, for_instr, return_instr;
non terminal funccall, funcparams, opebin, opeun, index, access, operand;

non terminal Idf lident;
non terminal String head;
non terminal Type typebase,type;
non terminal String array;

precedence left PLUS, MINUS, TIMES, DIVIDE, EQUALS, DIFF;
precedence left INF, SUP, INFEQUAL, SUPEQUAL, AND, OR, DOUBLEPOINTS;
precedence right TILDA, NOT;

//HEPIAL GRAMMAR RULES (ordered like the exemple in the pdf)


axiome::= programme;

programme::=  entete decla_star STARTPRG {: enterBlock(); :} body {: exitBlock(); :} ENDPRG;

entete::= PRG IDENT;

decla_star::= decla decla_star |  ;

decla::= declavar | declaconst | declafonct;

declavar::= type:t lident:id SEMICOLON
{:
  addSymbol(new Entry(id),new Symb(t,false));
:}
;

lident::=
    IDENT:id {:RESULT= new Idf(id);:}
    | lident COMMA IDENT:id {:RESULT= new Idf(id);:};

declaconst::= CONSTANT type:t IDENT:id EQUAL expr SEMICOLON
{:
    addSymbol(new Entry(new Idf(id)),new Symb(t,true));
:}
;

declafonct::=
    type IDENT OPENPARENT param CLOSEPARENT decla_star STARTFUNC {: enterBlock(); :} body {: exitBlock(); :} ENDFUNC
    |type IDENT OPENPARENT CLOSEPARENT decla_star STARTFUNC {: enterBlock(); :} body {: exitBlock(); :} ENDFUNC;

type::= typebase:tb {: RESULT=tb;:} | array:a ;

typebase::=
    TINTEGER {: RESULT= TypeInteger.getInstance(); :} |
    TBOOLEAN {: RESULT= TypeBoolean.getInstance(); :};

array::= typebase OPENBRACK dim CLOSEBRACK;

dim::=
    expr DOUBLEPOINTS expr
    |dim COMMA expr DOUBLEPOINTS expr;

param::=
    type IDENT
    |param COMMA type IDENT
    {:
        //TODO: check if need to add new symbol with func params?

        //TODO: use list of Ids ?
    :};


body ::= instr body
{:
    Block b = (Block) treeStack.pop();
    Instruction i = (Instruction) treeStack.pop();
    b.addInstructionBefore(i);
    treeStack.push(b);
:}
 | {: treeStack.push(new Block()); :};



instr::= affect | write_instr | read_instr | cond  | return_instr | while_instr | for_instr;

read_instr::= READ IDENT:id SEMICOLON
{:
    treeStack.push(new ReadInstr(new Idf(id)));
:};

write_instr::=
    WRITE expr SEMICOLON
    {:
        Expression e = (Expression) treeStack.pop();
        treeStack.push(new WriteInstr(e));
    :}
    |WRITE STRINGCONST SEMICOLON;

affect::= access EQUAL expr SEMICOLON
{:
    Expression source = (Expression) treeStack.pop();
    Idf dest= (Idf)treeStack.pop();
    treeStack.push(new Affectation(source,dest));
:};

return_instr::= RETURNSYM expr SEMICOLON
{:
   Expression expr = (Expression) treeStack.pop();
   treeStack.push(new ReturnInstr(expr));
 :};

cond::= IFSYM expr  THEN {: enterBlock(); :} body {: exitBlock(); :} ELSESYM {: enterBlock(); :} body {: exitBlock(); :} ENDIF
{:
    Block elseBlock= (Block)treeStack.pop();
    Block thenBlock= (Block)treeStack.pop();
    Expression cond= (Expression)treeStack.pop();
    treeStack.push(new Condition(cond,thenBlock,elseBlock));
:};

while_instr::= WHILESYM expr DOSYM {: enterBlock(); :} body {: exitBlock(); :} ENDWHILE
{:
    Block instructions= (Block)treeStack.pop();
    Expression cond= (Expression)treeStack.pop();
    treeStack.push(new WhileLoop(cond,instructions));
:};

for_instr::= FORSYM IDENT:var FROM expr TO expr DOSYM {: enterBlock(); :} body {: exitBlock(); :} ENDFOR
{:
    Block instructions =(Block)treeStack.pop();
    Expression upperBoundary = (Expression) treeStack.pop();
    Expression lowerBoundary = (Expression) treeStack.pop();
    treeStack.push(new ForLoop(new Idf(var),lowerBoundary,upperBoundary,instructions));
:};

expr::=
    expr opebin expr
    {:
        Expression right =(Expression)treeStack.pop();
        Binary oper = (Binary) treeStack.pop();
        Expression left = (Expression)treeStack.pop();
        oper.setLeft(left);
        oper.setRight(right);
        treeStack.push(oper);
    :}
    |opeun expr
    {:
        Expression exp= (Expression)treeStack.pop();
        Unary oper = (Unary)treeStack.pop();
        oper.setExp(exp);
        treeStack.push(oper);
    :}
    |OPENPARENT expr CLOSEPARENT
    |operand ;

access::= IDENT:name {:
    treeStack.push(new Idf(name));
:}| IDENT index PLUS;

index::= OPENBRACK expr CLOSEBRACK;

operand::= access | funccall
| INTEGERCONST:i {: treeStack.push(new IntNumber(i)); :}
| TRUESYM {: treeStack.push(new BooleanValue(true));:}
| FALSESYM {: treeStack.push(new BooleanValue(false)); :};

opebin::= PLUS{: treeStack.push(new Addition()); :}
|MINUS {: treeStack.push(new Substraction()); :}
|TIMES {: treeStack.push(new Multiplication()); :}
|DIVIDE{: treeStack.push(new Division()); :}
|EQUALS {: treeStack.push(new Equal()); :}
|DIFF {: treeStack.push(new NotEqual()); :}
|INF {: treeStack.push(new Inferior()); :}
|SUP {: treeStack.push(new Superior()); :}
|INFEQUAL {: treeStack.push(new InfEqual()); :}
|SUPEQUAL {: treeStack.push(new SupEqual()); :}
|AND {: treeStack.push(new And()); :}
|OR {: treeStack.push(new Or()); :};

opeun::=
TILDA {: treeStack.push(new Tilda()); :}
|NOT {: treeStack.push(new Not()); :};

funccall::=
    IDENT:id OPENPARENT CLOSEPARENT
    {:
        treeStack.push(new Call(new Idf(id)));
    :}
    | IDENT:id OPENPARENT funcparams CLOSEPARENT
    {:

        //TODO: check how to pass multiple params
    :}
    ;

funcparams::= expr | funcparams COMMA expr
    {:
    //TODO: use list of expression ?
    :}
;

