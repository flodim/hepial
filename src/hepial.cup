/*
Project: hepial compiler
Description: This is a compiler for hepial a custom language
			This si the cup file that contain the grammar rules.
Author: Florian Hassler & Dimitri Lizzi
Date: 14.01.2018
 */
import java_cup.runtime.*;
import java.io.*;
import symbole_table.*;
import abstract_tree.*;
import java.util.*;

parser code {:
private Stack<AbstractTree> treeStack;

private void enterBlock(){ SymbTable.getInstance().enterBlock(); }
private void exitBlock(){ SymbTable.getInstance().exitBlock();}
private void addSymbol(Entry entry, Symb symbol){  SymbTable.getInstance().add(entry,symbol); }

 :};

init with {:

treeStack=new Stack<AbstractTree>();

:};

terminal PRG, STARTPRG, ENDPRG, STARTFUNC, ENDFUNC, CONSTANT, COMMENT;
terminal SEMICOLON, OPENPARENT, CLOSEPARENT, EQUAL, COMMA, DOUBLEPOINTS;
terminal OPENBRACK, CLOSEBRACK, PLUS, MINUS, TILDA, TIMES, NOT, AND, OR, DIVIDE;
terminal EQUALS, DIFF, INF, SUP, INFEQUAL, SUPEQUAL, TRUESYM, FALSESYM;
terminal WHILESYM, DOSYM, ENDWHILE, IFSYM, THEN, ELSESYM, ENDIF;
terminal FORSYM, FROM, TO, ENDFOR, READ, WRITE, RETURNSYM;

terminal Integer INTEGERCONST;
terminal String STRINGCONST;
terminal String IDENT;
terminal String TINTEGER;
terminal String TBOOLEAN;

non terminal axiome, programme, entete, decla, declavar, declaconst ,decla_star, declafonct;
non terminal dim, expr, param, body, instr, affect;
non terminal write_instr, read_instr, cond, while_instr, for_instr, return_instr;
non terminal funccall, funcparams, opebin, opeun, index, access, operand;

non terminal String lident;
non terminal String head;
non terminal Type typebase,type;
non terminal String array;

precedence left PLUS, MINUS, TIMES, DIVIDE, EQUALS, DIFF;
precedence left INF, SUP, INFEQUAL, SUPEQUAL, AND, OR, DOUBLEPOINTS;
precedence right TILDA, NOT;

//HEPIAL GRAMMAR RULES (ordered like the exemple in the pdf)


axiome::= programme;

programme::=  entete decla_star STARTPRG {: enterBlock(); :} body {: exitBlock(); :} ENDPRG;

entete::= PRG IDENT;

decla_star::= decla decla_star |  ;

decla::= declavar | declaconst | declafonct;

declavar::= type:t lident:id SEMICOLON
{:
  addSymbol(new Entry(id),new Symb(t,false));
:}
;

lident::=
    IDENT:id {:RESULT=id;:}
    | lident COMMA IDENT:id {:RESULT=id;:};

declaconst::= CONSTANT type:t IDENT:id EQUAL expr SEMICOLON
{:
    addSymbol(new Entry(id),new Symb(t,true));
:}
;

declafonct::=
    type IDENT OPENPARENT param CLOSEPARENT decla_star STARTFUNC {: enterBlock(); :} body {: exitBlock(); :} ENDFUNC
    |type IDENT OPENPARENT CLOSEPARENT decla_star STARTFUNC {: enterBlock(); :} body {: exitBlock(); :} ENDFUNC;

type::= typebase:tb {: RESULT=tb;:} | array:a ;

typebase::=
    TINTEGER {: RESULT= TypeInteger.getInstance();:} |
    TBOOLEAN {: RESULT= TypeBoolean.getInstance();:}
 ;

array::= typebase OPENBRACK dim CLOSEBRACK;

dim::=
    expr DOUBLEPOINTS expr
    |dim COMMA expr DOUBLEPOINTS expr;

param::=
    type IDENT
    |param COMMA type IDENT;

body ::= instr body
{:
    Instruction i = (Instruction) treeStack.pop();
    Block b = (Block) treeStack.pop();
    treeStack.push(new Block(i,b));

:} | {: treeStack.push(new Block()); :} ;



instr::= affect | write_instr | read_instr | cond  | return_instr | while_instr | for_instr;

read_instr::= READ IDENT SEMICOLON;

write_instr::=
    WRITE expr SEMICOLON
    |WRITE STRINGCONST SEMICOLON;

affect::= access EQUAL expr SEMICOLON
{:
    Expression source = (Expression) treeStack.pop();
    Idf dest= (Idf)treeStack.pop();
    treeStack.push(new Affectation(source,dest));
:};

return_instr::= RETURNSYM expr SEMICOLON;

cond::= IFSYM expr  THEN {: enterBlock(); :} body {: exitBlock(); :} ELSESYM {: enterBlock(); :} body {: exitBlock(); :} ENDIF
{:
    Block elseBlock= (Block)treeStack.pop();
    Block thenBlock= (Block)treeStack.pop();
    Expression cond= (Expression)treeStack.pop();
    treeStack.push(new Condition(cond,thenBlock,elseBlock));
:}
;

while_instr::= WHILESYM expr DOSYM {: enterBlock(); :} body {: exitBlock(); :} ENDWHILE;

for_instr::= FORSYM IDENT FROM expr TO expr DOSYM {: enterBlock(); :} body {: exitBlock(); :} ENDFOR;

expr::=
    expr opebin expr
    {:
        Expression right =(Expression)treeStack.pop();
        Binary oper = (Binary) treeStack.pop();
        Expression left = (Expression)treeStack.pop();
        oper.setLeft(left);
        oper.setRight(right);
        treeStack.push(oper);
    :}
    |opeun expr
    |OPENPARENT expr CLOSEPARENT
    |operand ;

access::= IDENT:name {:
    treeStack.push(new Idf(name));
:}| IDENT index PLUS;

index::= OPENBRACK expr CLOSEBRACK;

operand::= access | funccall | INTEGERCONST:i
{:
   treeStack.push(new IntNumber(i));
:} | TRUESYM | FALSESYM;

opebin::= PLUS{: treeStack.push(new Addition()); :}
|MINUS {: treeStack.push(new Substraction()); :}
|TIMES {: treeStack.push(new Multiplication()); :}
|DIVIDE{: treeStack.push(new Division()); :}
|EQUALS {: treeStack.push(new Equal()); :}
|DIFF {: treeStack.push(new NotEqual()); :}
|INF {: treeStack.push(new Inferior()); :}
|SUP {: treeStack.push(new Superior()); :}
|INFEQUAL {: treeStack.push(new InfEqual()); :}
|SUPEQUAL {: treeStack.push(new SupEqual()); :}
|AND |OR;

opeun::=TILDA|NOT;

funccall::=
    IDENT OPENPARENT CLOSEPARENT
    | IDENT OPENPARENT funcparams CLOSEPARENT;

funcparams::= expr | funcparams COMMA expr;

